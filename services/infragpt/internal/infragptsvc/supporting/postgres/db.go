// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package postgres

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.addChannelStmt, err = db.PrepareContext(ctx, addChannel); err != nil {
		return nil, fmt.Errorf("error preparing query AddChannel: %w", err)
	}
	if q.conversationStmt, err = db.PrepareContext(ctx, conversation); err != nil {
		return nil, fmt.Errorf("error preparing query Conversation: %w", err)
	}
	if q.createConversationStmt, err = db.PrepareContext(ctx, createConversation); err != nil {
		return nil, fmt.Errorf("error preparing query CreateConversation: %w", err)
	}
	if q.getConversationByThreadStmt, err = db.PrepareContext(ctx, getConversationByThread); err != nil {
		return nil, fmt.Errorf("error preparing query GetConversationByThread: %w", err)
	}
	if q.getConversationHistoryStmt, err = db.PrepareContext(ctx, getConversationHistory); err != nil {
		return nil, fmt.Errorf("error preparing query GetConversationHistory: %w", err)
	}
	if q.getConversationHistoryDescStmt, err = db.PrepareContext(ctx, getConversationHistoryDesc); err != nil {
		return nil, fmt.Errorf("error preparing query GetConversationHistoryDesc: %w", err)
	}
	if q.getMonitoredChannelsStmt, err = db.PrepareContext(ctx, getMonitoredChannels); err != nil {
		return nil, fmt.Errorf("error preparing query GetMonitoredChannels: %w", err)
	}
	if q.isChannelMonitoredStmt, err = db.PrepareContext(ctx, isChannelMonitored); err != nil {
		return nil, fmt.Errorf("error preparing query IsChannelMonitored: %w", err)
	}
	if q.messageBySlackTSStmt, err = db.PrepareContext(ctx, messageBySlackTS); err != nil {
		return nil, fmt.Errorf("error preparing query MessageBySlackTS: %w", err)
	}
	if q.setChannelMonitoringStmt, err = db.PrepareContext(ctx, setChannelMonitoring); err != nil {
		return nil, fmt.Errorf("error preparing query SetChannelMonitoring: %w", err)
	}
	if q.storeMessageStmt, err = db.PrepareContext(ctx, storeMessage); err != nil {
		return nil, fmt.Errorf("error preparing query StoreMessage: %w", err)
	}
	if q.updateConversationTimestampStmt, err = db.PrepareContext(ctx, updateConversationTimestamp); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateConversationTimestamp: %w", err)
	}
	if q.integrationsStmt, err = db.PrepareContext(ctx, integrations); err != nil {
		return nil, fmt.Errorf("error preparing query integrations: %w", err)
	}
	if q.saveIntegrationStmt, err = db.PrepareContext(ctx, saveIntegration); err != nil {
		return nil, fmt.Errorf("error preparing query saveIntegration: %w", err)
	}
	if q.saveSlackTokenStmt, err = db.PrepareContext(ctx, saveSlackToken); err != nil {
		return nil, fmt.Errorf("error preparing query saveSlackToken: %w", err)
	}
	if q.slackTokenStmt, err = db.PrepareContext(ctx, slackToken); err != nil {
		return nil, fmt.Errorf("error preparing query slackToken: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.addChannelStmt != nil {
		if cerr := q.addChannelStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing addChannelStmt: %w", cerr)
		}
	}
	if q.conversationStmt != nil {
		if cerr := q.conversationStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing conversationStmt: %w", cerr)
		}
	}
	if q.createConversationStmt != nil {
		if cerr := q.createConversationStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createConversationStmt: %w", cerr)
		}
	}
	if q.getConversationByThreadStmt != nil {
		if cerr := q.getConversationByThreadStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getConversationByThreadStmt: %w", cerr)
		}
	}
	if q.getConversationHistoryStmt != nil {
		if cerr := q.getConversationHistoryStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getConversationHistoryStmt: %w", cerr)
		}
	}
	if q.getConversationHistoryDescStmt != nil {
		if cerr := q.getConversationHistoryDescStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getConversationHistoryDescStmt: %w", cerr)
		}
	}
	if q.getMonitoredChannelsStmt != nil {
		if cerr := q.getMonitoredChannelsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getMonitoredChannelsStmt: %w", cerr)
		}
	}
	if q.isChannelMonitoredStmt != nil {
		if cerr := q.isChannelMonitoredStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing isChannelMonitoredStmt: %w", cerr)
		}
	}
	if q.messageBySlackTSStmt != nil {
		if cerr := q.messageBySlackTSStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing messageBySlackTSStmt: %w", cerr)
		}
	}
	if q.setChannelMonitoringStmt != nil {
		if cerr := q.setChannelMonitoringStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing setChannelMonitoringStmt: %w", cerr)
		}
	}
	if q.storeMessageStmt != nil {
		if cerr := q.storeMessageStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing storeMessageStmt: %w", cerr)
		}
	}
	if q.updateConversationTimestampStmt != nil {
		if cerr := q.updateConversationTimestampStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateConversationTimestampStmt: %w", cerr)
		}
	}
	if q.integrationsStmt != nil {
		if cerr := q.integrationsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing integrationsStmt: %w", cerr)
		}
	}
	if q.saveIntegrationStmt != nil {
		if cerr := q.saveIntegrationStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing saveIntegrationStmt: %w", cerr)
		}
	}
	if q.saveSlackTokenStmt != nil {
		if cerr := q.saveSlackTokenStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing saveSlackTokenStmt: %w", cerr)
		}
	}
	if q.slackTokenStmt != nil {
		if cerr := q.slackTokenStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing slackTokenStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                              DBTX
	tx                              *sql.Tx
	addChannelStmt                  *sql.Stmt
	conversationStmt                *sql.Stmt
	createConversationStmt          *sql.Stmt
	getConversationByThreadStmt     *sql.Stmt
	getConversationHistoryStmt      *sql.Stmt
	getConversationHistoryDescStmt  *sql.Stmt
	getMonitoredChannelsStmt        *sql.Stmt
	isChannelMonitoredStmt          *sql.Stmt
	messageBySlackTSStmt            *sql.Stmt
	setChannelMonitoringStmt        *sql.Stmt
	storeMessageStmt                *sql.Stmt
	updateConversationTimestampStmt *sql.Stmt
	integrationsStmt                *sql.Stmt
	saveIntegrationStmt             *sql.Stmt
	saveSlackTokenStmt              *sql.Stmt
	slackTokenStmt                  *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                              tx,
		tx:                              tx,
		addChannelStmt:                  q.addChannelStmt,
		conversationStmt:                q.conversationStmt,
		createConversationStmt:          q.createConversationStmt,
		getConversationByThreadStmt:     q.getConversationByThreadStmt,
		getConversationHistoryStmt:      q.getConversationHistoryStmt,
		getConversationHistoryDescStmt:  q.getConversationHistoryDescStmt,
		getMonitoredChannelsStmt:        q.getMonitoredChannelsStmt,
		isChannelMonitoredStmt:          q.isChannelMonitoredStmt,
		messageBySlackTSStmt:            q.messageBySlackTSStmt,
		setChannelMonitoringStmt:        q.setChannelMonitoringStmt,
		storeMessageStmt:                q.storeMessageStmt,
		updateConversationTimestampStmt: q.updateConversationTimestampStmt,
		integrationsStmt:                q.integrationsStmt,
		saveIntegrationStmt:             q.saveIntegrationStmt,
		saveSlackTokenStmt:              q.saveSlackTokenStmt,
		slackTokenStmt:                  q.slackTokenStmt,
	}
}
