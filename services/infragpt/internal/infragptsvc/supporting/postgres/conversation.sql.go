// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: conversation.sql

package postgres

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addChannel = `-- name: AddChannel :exec
INSERT INTO channels (team_id, channel_id, channel_name, is_monitored)
VALUES ($1, $2, $3, false)
ON CONFLICT (team_id, channel_id) 
DO UPDATE SET channel_name = EXCLUDED.channel_name
`

type AddChannelParams struct {
	TeamID      string         `json:"team_id"`
	ChannelID   string         `json:"channel_id"`
	ChannelName sql.NullString `json:"channel_name"`
}

func (q *Queries) AddChannel(ctx context.Context, arg AddChannelParams) error {
	_, err := q.exec(ctx, q.addChannelStmt, addChannel, arg.TeamID, arg.ChannelID, arg.ChannelName)
	return err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (team_id, channel_id, thread_ts)
VALUES ($1, $2, $3)
RETURNING conversation_id, team_id, channel_id, thread_ts, created_at, updated_at
`

type CreateConversationParams struct {
	TeamID    string `json:"team_id"`
	ChannelID string `json:"channel_id"`
	ThreadTs  string `json:"thread_ts"`
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (Conversation, error) {
	row := q.queryRow(ctx, q.createConversationStmt, createConversation, arg.TeamID, arg.ChannelID, arg.ThreadTs)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.TeamID,
		&i.ChannelID,
		&i.ThreadTs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationByThread = `-- name: GetConversationByThread :one
SELECT conversation_id, team_id, channel_id, thread_ts, created_at, updated_at
FROM conversations
WHERE team_id = $1 AND channel_id = $2 AND thread_ts = $3
`

type GetConversationByThreadParams struct {
	TeamID    string `json:"team_id"`
	ChannelID string `json:"channel_id"`
	ThreadTs  string `json:"thread_ts"`
}

func (q *Queries) GetConversationByThread(ctx context.Context, arg GetConversationByThreadParams) (Conversation, error) {
	row := q.queryRow(ctx, q.getConversationByThreadStmt, getConversationByThread, arg.TeamID, arg.ChannelID, arg.ThreadTs)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.TeamID,
		&i.ChannelID,
		&i.ThreadTs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationHistory = `-- name: GetConversationHistory :many
SELECT message_id, conversation_id, slack_message_ts, sender_user_id, sender_username, sender_email, sender_name, message_text, is_bot_message, created_at
FROM messages
WHERE conversation_id = $1
ORDER BY created_at ASC
LIMIT $2
`

type GetConversationHistoryParams struct {
	ConversationID uuid.UUID `json:"conversation_id"`
	Limit          int32     `json:"limit"`
}

func (q *Queries) GetConversationHistory(ctx context.Context, arg GetConversationHistoryParams) ([]Message, error) {
	rows, err := q.query(ctx, q.getConversationHistoryStmt, getConversationHistory, arg.ConversationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SlackMessageTs,
			&i.SenderUserID,
			&i.SenderUsername,
			&i.SenderEmail,
			&i.SenderName,
			&i.MessageText,
			&i.IsBotMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationHistoryDesc = `-- name: GetConversationHistoryDesc :many
SELECT message_id, conversation_id, slack_message_ts, sender_user_id, sender_username, sender_email, sender_name, message_text, is_bot_message, created_at
FROM messages
WHERE conversation_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetConversationHistoryDescParams struct {
	ConversationID uuid.UUID `json:"conversation_id"`
	Limit          int32     `json:"limit"`
}

func (q *Queries) GetConversationHistoryDesc(ctx context.Context, arg GetConversationHistoryDescParams) ([]Message, error) {
	rows, err := q.query(ctx, q.getConversationHistoryDescStmt, getConversationHistoryDesc, arg.ConversationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SlackMessageTs,
			&i.SenderUserID,
			&i.SenderUsername,
			&i.SenderEmail,
			&i.SenderName,
			&i.MessageText,
			&i.IsBotMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitoredChannels = `-- name: GetMonitoredChannels :many
SELECT channel_id, team_id, channel_name, is_monitored, created_at
FROM channels
WHERE team_id = $1 AND is_monitored = true
`

func (q *Queries) GetMonitoredChannels(ctx context.Context, teamID string) ([]Channel, error) {
	rows, err := q.query(ctx, q.getMonitoredChannelsStmt, getMonitoredChannels, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Channel
	for rows.Next() {
		var i Channel
		if err := rows.Scan(
			&i.ChannelID,
			&i.TeamID,
			&i.ChannelName,
			&i.IsMonitored,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isChannelMonitored = `-- name: IsChannelMonitored :one
SELECT COALESCE(is_monitored, false) as is_monitored
FROM channels
WHERE team_id = $1 AND channel_id = $2
`

type IsChannelMonitoredParams struct {
	TeamID    string `json:"team_id"`
	ChannelID string `json:"channel_id"`
}

func (q *Queries) IsChannelMonitored(ctx context.Context, arg IsChannelMonitoredParams) (bool, error) {
	row := q.queryRow(ctx, q.isChannelMonitoredStmt, isChannelMonitored, arg.TeamID, arg.ChannelID)
	var is_monitored bool
	err := row.Scan(&is_monitored)
	return is_monitored, err
}

const messageBySlackTS = `-- name: MessageBySlackTS :one
SELECT message_id, conversation_id, slack_message_ts, sender_user_id, sender_username, sender_email, sender_name, message_text, is_bot_message, created_at
FROM messages
WHERE conversation_id = $1 AND slack_message_ts = $2 AND sender_user_id = $3
`

type MessageBySlackTSParams struct {
	ConversationID uuid.UUID `json:"conversation_id"`
	SlackMessageTs string    `json:"slack_message_ts"`
	SenderUserID   string    `json:"sender_user_id"`
}

func (q *Queries) MessageBySlackTS(ctx context.Context, arg MessageBySlackTSParams) (Message, error) {
	row := q.queryRow(ctx, q.messageBySlackTSStmt, messageBySlackTS, arg.ConversationID, arg.SlackMessageTs, arg.SenderUserID)
	var i Message
	err := row.Scan(
		&i.MessageID,
		&i.ConversationID,
		&i.SlackMessageTs,
		&i.SenderUserID,
		&i.SenderUsername,
		&i.SenderEmail,
		&i.SenderName,
		&i.MessageText,
		&i.IsBotMessage,
		&i.CreatedAt,
	)
	return i, err
}

const setChannelMonitoring = `-- name: SetChannelMonitoring :exec
UPDATE channels
SET is_monitored = $3
WHERE team_id = $1 AND channel_id = $2
`

type SetChannelMonitoringParams struct {
	TeamID      string `json:"team_id"`
	ChannelID   string `json:"channel_id"`
	IsMonitored bool   `json:"is_monitored"`
}

func (q *Queries) SetChannelMonitoring(ctx context.Context, arg SetChannelMonitoringParams) error {
	_, err := q.exec(ctx, q.setChannelMonitoringStmt, setChannelMonitoring, arg.TeamID, arg.ChannelID, arg.IsMonitored)
	return err
}

const storeMessage = `-- name: StoreMessage :one
INSERT INTO messages (conversation_id, slack_message_ts, sender_user_id, sender_username, sender_email, sender_name, message_text, is_bot_message)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING message_id, conversation_id, slack_message_ts, sender_user_id, sender_username, sender_email, sender_name, message_text, is_bot_message, created_at
`

type StoreMessageParams struct {
	ConversationID uuid.UUID      `json:"conversation_id"`
	SlackMessageTs string         `json:"slack_message_ts"`
	SenderUserID   string         `json:"sender_user_id"`
	SenderUsername sql.NullString `json:"sender_username"`
	SenderEmail    sql.NullString `json:"sender_email"`
	SenderName     sql.NullString `json:"sender_name"`
	MessageText    string         `json:"message_text"`
	IsBotMessage   bool           `json:"is_bot_message"`
}

func (q *Queries) StoreMessage(ctx context.Context, arg StoreMessageParams) (Message, error) {
	row := q.queryRow(ctx, q.storeMessageStmt, storeMessage,
		arg.ConversationID,
		arg.SlackMessageTs,
		arg.SenderUserID,
		arg.SenderUsername,
		arg.SenderEmail,
		arg.SenderName,
		arg.MessageText,
		arg.IsBotMessage,
	)
	var i Message
	err := row.Scan(
		&i.MessageID,
		&i.ConversationID,
		&i.SlackMessageTs,
		&i.SenderUserID,
		&i.SenderUsername,
		&i.SenderEmail,
		&i.SenderName,
		&i.MessageText,
		&i.IsBotMessage,
		&i.CreatedAt,
	)
	return i, err
}

const updateConversationTimestamp = `-- name: UpdateConversationTimestamp :exec
UPDATE conversations
SET updated_at = NOW()
WHERE conversation_id = $1
`

func (q *Queries) UpdateConversationTimestamp(ctx context.Context, conversationID uuid.UUID) error {
	_, err := q.exec(ctx, q.updateConversationTimestampStmt, updateConversationTimestamp, conversationID)
	return err
}
