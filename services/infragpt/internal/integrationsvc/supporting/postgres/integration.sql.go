// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: integration.sql

package postgres

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const deleteIntegration = `-- name: DeleteIntegration :exec
DELETE FROM integrations
WHERE id = $1
`

func (q *Queries) DeleteIntegration(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteIntegrationStmt, deleteIntegration, id)
	return err
}

const findIntegrationByBotIDAndType = `-- name: FindIntegrationByBotIDAndType :one
SELECT id, organization_id, user_id, connector_type, status,
       bot_id, connector_user_id, connector_organization_id,
       metadata, created_at, updated_at, last_used_at
FROM integrations
WHERE bot_id = $1 AND connector_type = $2
`

type FindIntegrationByBotIDAndTypeParams struct {
	BotID         sql.NullString `json:"bot_id"`
	ConnectorType string         `json:"connector_type"`
}

func (q *Queries) FindIntegrationByBotIDAndType(ctx context.Context, arg FindIntegrationByBotIDAndTypeParams) (Integration, error) {
	row := q.queryRow(ctx, q.findIntegrationByBotIDAndTypeStmt, findIntegrationByBotIDAndType, arg.BotID, arg.ConnectorType)
	var i Integration
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.ConnectorType,
		&i.Status,
		&i.BotID,
		&i.ConnectorUserID,
		&i.ConnectorOrganizationID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const findIntegrationByID = `-- name: FindIntegrationByID :one
SELECT id, organization_id, user_id, connector_type, status,
       bot_id, connector_user_id, connector_organization_id,
       metadata, created_at, updated_at, last_used_at
FROM integrations
WHERE id = $1
`

func (q *Queries) FindIntegrationByID(ctx context.Context, id uuid.UUID) (Integration, error) {
	row := q.queryRow(ctx, q.findIntegrationByIDStmt, findIntegrationByID, id)
	var i Integration
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.ConnectorType,
		&i.Status,
		&i.BotID,
		&i.ConnectorUserID,
		&i.ConnectorOrganizationID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const findIntegrationsByOrganization = `-- name: FindIntegrationsByOrganization :many
SELECT id, organization_id, user_id, connector_type, status,
       bot_id, connector_user_id, connector_organization_id,
       metadata, created_at, updated_at, last_used_at
FROM integrations
WHERE organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindIntegrationsByOrganization(ctx context.Context, organizationID uuid.UUID) ([]Integration, error) {
	rows, err := q.query(ctx, q.findIntegrationsByOrganizationStmt, findIntegrationsByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Integration
	for rows.Next() {
		var i Integration
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.ConnectorType,
			&i.Status,
			&i.BotID,
			&i.ConnectorUserID,
			&i.ConnectorOrganizationID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findIntegrationsByOrganizationAndType = `-- name: FindIntegrationsByOrganizationAndType :many
SELECT id, organization_id, user_id, connector_type, status,
       bot_id, connector_user_id, connector_organization_id,
       metadata, created_at, updated_at, last_used_at
FROM integrations
WHERE organization_id = $1 AND connector_type = $2
ORDER BY created_at DESC
`

type FindIntegrationsByOrganizationAndTypeParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	ConnectorType  string    `json:"connector_type"`
}

func (q *Queries) FindIntegrationsByOrganizationAndType(ctx context.Context, arg FindIntegrationsByOrganizationAndTypeParams) ([]Integration, error) {
	rows, err := q.query(ctx, q.findIntegrationsByOrganizationAndTypeStmt, findIntegrationsByOrganizationAndType, arg.OrganizationID, arg.ConnectorType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Integration
	for rows.Next() {
		var i Integration
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.ConnectorType,
			&i.Status,
			&i.BotID,
			&i.ConnectorUserID,
			&i.ConnectorOrganizationID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeIntegration = `-- name: StoreIntegration :exec
INSERT INTO integrations (
    id, organization_id, user_id, connector_type, status, 
    bot_id, connector_user_id, connector_organization_id, 
    metadata, created_at, updated_at, last_used_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
`

type StoreIntegrationParams struct {
	ID                      uuid.UUID             `json:"id"`
	OrganizationID          uuid.UUID             `json:"organization_id"`
	UserID                  uuid.UUID             `json:"user_id"`
	ConnectorType           string                `json:"connector_type"`
	Status                  string                `json:"status"`
	BotID                   sql.NullString        `json:"bot_id"`
	ConnectorUserID         sql.NullString        `json:"connector_user_id"`
	ConnectorOrganizationID sql.NullString        `json:"connector_organization_id"`
	Metadata                pqtype.NullRawMessage `json:"metadata"`
	CreatedAt               time.Time             `json:"created_at"`
	UpdatedAt               time.Time             `json:"updated_at"`
	LastUsedAt              sql.NullTime          `json:"last_used_at"`
}

func (q *Queries) StoreIntegration(ctx context.Context, arg StoreIntegrationParams) error {
	_, err := q.exec(ctx, q.storeIntegrationStmt, storeIntegration,
		arg.ID,
		arg.OrganizationID,
		arg.UserID,
		arg.ConnectorType,
		arg.Status,
		arg.BotID,
		arg.ConnectorUserID,
		arg.ConnectorOrganizationID,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LastUsedAt,
	)
	return err
}

const updateIntegration = `-- name: UpdateIntegration :exec
UPDATE integrations
SET connector_type = $2,
    status = $3,
    bot_id = $4,
    connector_user_id = $5,
    connector_organization_id = $6,
    metadata = $7,
    updated_at = $8,
    last_used_at = $9
WHERE id = $1
`

type UpdateIntegrationParams struct {
	ID                      uuid.UUID             `json:"id"`
	ConnectorType           string                `json:"connector_type"`
	Status                  string                `json:"status"`
	BotID                   sql.NullString        `json:"bot_id"`
	ConnectorUserID         sql.NullString        `json:"connector_user_id"`
	ConnectorOrganizationID sql.NullString        `json:"connector_organization_id"`
	Metadata                pqtype.NullRawMessage `json:"metadata"`
	UpdatedAt               time.Time             `json:"updated_at"`
	LastUsedAt              sql.NullTime          `json:"last_used_at"`
}

func (q *Queries) UpdateIntegration(ctx context.Context, arg UpdateIntegrationParams) error {
	_, err := q.exec(ctx, q.updateIntegrationStmt, updateIntegration,
		arg.ID,
		arg.ConnectorType,
		arg.Status,
		arg.BotID,
		arg.ConnectorUserID,
		arg.ConnectorOrganizationID,
		arg.Metadata,
		arg.UpdatedAt,
		arg.LastUsedAt,
	)
	return err
}

const updateIntegrationLastUsed = `-- name: UpdateIntegrationLastUsed :exec
UPDATE integrations
SET last_used_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateIntegrationLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.updateIntegrationLastUsedStmt, updateIntegrationLastUsed, id)
	return err
}

const updateIntegrationMetadata = `-- name: UpdateIntegrationMetadata :exec
UPDATE integrations
SET metadata = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateIntegrationMetadataParams struct {
	ID       uuid.UUID             `json:"id"`
	Metadata pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) UpdateIntegrationMetadata(ctx context.Context, arg UpdateIntegrationMetadataParams) error {
	_, err := q.exec(ctx, q.updateIntegrationMetadataStmt, updateIntegrationMetadata, arg.ID, arg.Metadata)
	return err
}

const updateIntegrationStatus = `-- name: UpdateIntegrationStatus :exec
UPDATE integrations
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateIntegrationStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateIntegrationStatus(ctx context.Context, arg UpdateIntegrationStatusParams) error {
	_, err := q.exec(ctx, q.updateIntegrationStatusStmt, updateIntegrationStatus, arg.ID, arg.Status)
	return err
}
